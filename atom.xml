<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Guwen's Studio]]></title>
  <subtitle><![CDATA[Guwen's Studio]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://gwpost.github.com/"/>
  <updated>2016-04-23T14:19:20.331Z</updated>
  <id>http://gwpost.github.com/</id>
  
  <author>
    <name><![CDATA[Gu Wen]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Installing Docker on RaspberryPi]]></title>
    <link href="http://gwpost.github.com/2016/04/23/docker/docker-on-raspberrypi/"/>
    <id>http://gwpost.github.com/2016/04/23/docker/docker-on-raspberrypi/</id>
    <published>2016-04-23T07:45:35.000Z</published>
    <updated>2016-04-23T14:19:20.331Z</updated>
    <content type="html"><![CDATA[<p>This tutorial describes useful things if you want to set up and run Docker on your RaspberryPi from scratch. If you prefer a ready to use image you may want to read <a href="http://blog.hypriot.com/post/brand-new-getting-started-guide/" target="_blank" rel="external">this article</a> and take the image provided by the <a href="http://blog.hypriot.com/" target="_blank" rel="external">Hypriot team</a>. As always some people feel better if they can do the set up by themselves and don’t need to trust other people’s images. If you belong to this particular group you may want to continue reading.</p>
<h2 id="1-Before_you_start">1.Before you start</h2><p>You will need a Raspberry Pi running Raspbian. I’ve taken the stand alone image (and not NOOBS), since I wanted to use the Raspberry Pi headless.</p>
<h2 id="2-Make_a_raspbian_server_from_a_default_raspbian_image">2.Make a raspbian server from a default raspbian image</h2><p>The official Raspbian comes with a lot of packages pre-installed, many of them don’t make sense if you want to run the Raspberry Pi as a server (e.g. without a display attached). So I’ve decided to delete packages I’m not going to miss very much (thanks to <a href="http://www.cnx-software.com/2012/07/31/84-mb-minimal-raspbian-armhf-image-for-raspberry-pi/" target="_blank" rel="external">cnxsoft</a>).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep x11 | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep python | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep sound | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep gnome | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep lxde | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep gtk | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep desktop | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep gstreamer | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep avahi | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep dbus | sed s/install//`</span><br><span class="line">$ sudo apt-get -y remove `sudo dpkg --get-selections | grep -v <span class="string">"deinstall"</span> | grep freetype | sed s/install//`</span><br><span class="line">$ sudo apt-get -y autoremove</span><br><span class="line">$ sudo apt-get clean</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Update_to_Debian_8_(Jessie)">3.Update to Debian 8 (Jessie)</h2><p>Debian 8 for the Raspberry Pi already comes with a Docker enabled kernel, but you have to run the update on your own (there is no ready to use Debian 8 image available for download at this time.). I’ve found this tutorial very helpful for updating to Debian 8.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sed -i <span class="string">'s/wheezy/jessie/'</span> /etc/apt/sources.list</span><br><span class="line">$ sudo sed -i <span class="string">'s/wheezy/jessie/'</span> /etc/apt/sources.list.d/raspi.list</span><br><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get -y upgrade <span class="comment"># answer 'y' to upcoming questions</span></span><br><span class="line">$ sudo sudo apt-get -y dist-upgrade <span class="comment"># answer 'y' to upcoming questions</span></span><br><span class="line">$ sudo init <span class="number">6</span></span><br><span class="line">$ sudo apt-get -y autoremove</span><br><span class="line">$ sudo apt-get -y purge $(dpkg <span class="operator">-l</span> | awk <span class="string">'/^rc/ &#123; print $2 &#125;'</span>)</span><br><span class="line">$ sudo init <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-Build_the_Docker_installation_package_(optional)">4.Build the Docker installation package (optional)</h2><p>The Hypriot team has made a great job, automating the process of building a raspbian wheezy package for Docker, with Docker on ARM. Any docker enabled ARMv7 device will work as well. If you don’t have any, you may take a look at Scaleway, they offer AWS like services based on ARMv7:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/hypriot/rpi-docker-builder.git</span><br><span class="line">$ <span class="built_in">cd</span> rpi-docker-builder</span><br><span class="line">$ sudo sh build.sh</span><br><span class="line">$ sudo sh run-builder.sh</span><br></pre></td></tr></table></figure></p>
<p>You will find the docker install package in ./dist/docker-hypriot_1.8.1-1_armhf.deb.</p>
<h2 id="5-Install_the_docker_installation_package_on_your_Raspberry_Pi">5.Install the docker installation package on your Raspberry Pi</h2><p>The Hypriot team offers the <a href="http://blog.hypriot.com/downloads/" target="_blank" rel="external">installation package</a> for download now, you don’t need to create the installation package by yourself.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="operator">-s</span>SL http://downloads.hypriot.com/docker-hypriot_1.<span class="number">8.1</span>-<span class="number">1</span>_armhf.deb &gt;/tmp/docker-hypriot_1.<span class="number">8.1</span>-<span class="number">1</span>_armhf.deb</span><br><span class="line">$ sudo dpkg -i /tmp/docker-hypriot_1.<span class="number">8.1</span>-<span class="number">1</span>_armhf.deb</span><br><span class="line">$ rm <span class="operator">-f</span> /tmp/docker-hypriot_1.<span class="number">8.1</span>-<span class="number">1</span>_armhf.deb</span><br><span class="line">$ sudo sh -c <span class="string">'usermod -aG docker $SUDO_USER'</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker.service</span><br></pre></td></tr></table></figure></p>
<h2 id="6-See_if_it_works">6.See if it works</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker info</span><br><span class="line">Containers: <span class="number">0</span></span><br><span class="line">Images: <span class="number">0</span></span><br><span class="line">Storage Driver: overlay</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line">Execution Driver: native-<span class="number">0.2</span></span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Kernel Version: <span class="number">4.1</span>.<span class="number">6</span>+</span><br><span class="line">Operating System: Raspbian GNU/Linux <span class="number">8</span> (jessie)</span><br><span class="line">CPUs: <span class="number">1</span></span><br><span class="line">Total Memory: <span class="number">434.6</span> MiB</span><br><span class="line">Name: raspberrypi</span><br><span class="line">ID: <span class="number">75</span>UW:<span class="number">4</span>ZHU:JAQV:GYD3:EYZO:X47C:R3VE:<span class="number">36</span>X4:<span class="number">2</span>B2Q:SNNC:<span class="number">5</span>XE5:<span class="number">3</span>QUW</span><br><span class="line">Debug mode (server): <span class="literal">true</span></span><br><span class="line">File Descriptors: <span class="number">11</span></span><br><span class="line">Goroutines: <span class="number">21</span></span><br><span class="line">System Time: <span class="number">2015</span>-<span class="number">08</span>-<span class="number">30</span>T12:<span class="number">05</span>:<span class="number">37.926439017</span>Z</span><br><span class="line">EventsListeners: <span class="number">0</span></span><br><span class="line">Init SHA1: <span class="number">96</span>cfebcba660bb855cca9d1d6af72fef27a5e953</span><br><span class="line">Init Path: /usr/lib/docker/dockerinit</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">WARNING: No memory <span class="built_in">limit</span> support</span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support</span><br><span class="line"></span><br><span class="line">$ docker version</span><br><span class="line">pi@raspberrypi ~ $ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      <span class="number">1.8</span>.<span class="number">1</span></span><br><span class="line"> API version:  <span class="number">1.20</span></span><br><span class="line"> Go version:   go1.<span class="number">4.2</span></span><br><span class="line"> Git commit:   d12ea79-dirty</span><br><span class="line"> Built:        Thu Aug <span class="number">13</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">24</span> UTC <span class="number">2015</span></span><br><span class="line"> OS/Arch:      linux/arm</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      <span class="number">1.8</span>.<span class="number">1</span></span><br><span class="line"> API version:  <span class="number">1.20</span></span><br><span class="line"> Go version:   go1.<span class="number">4.2</span></span><br><span class="line"> Git commit:   d12ea79-dirty</span><br><span class="line"> Built:        Thu Aug <span class="number">13</span> <span class="number">07</span>:<span class="number">53</span>:<span class="number">24</span> UTC <span class="number">2015</span></span><br><span class="line"> OS/Arch:      linux/arm</span><br><span class="line"></span><br><span class="line">$ docker run -i -t resin/rpi-raspbian</span><br><span class="line">Unable to find image <span class="string">'resin/rpi-raspbian:latest'</span> locally</span><br><span class="line">latest: Pulling from resin/rpi-raspbian</span><br><span class="line"><span class="number">0</span>ff226ee0b3d: Pull complete</span><br><span class="line"><span class="number">53</span>d5a0644416: Pull complete</span><br><span class="line"><span class="number">699</span>e67a59feb: Pull complete</span><br><span class="line">cfbba98e0d58: Already exists</span><br><span class="line">Digest: sha256:<span class="number">0</span>ae72af3cecc0f940b694d7a7a3ccf7003da9460d0cc0d0d9646a8b0d8be9d84</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> resin/rpi-raspbian:latest</span><br><span class="line">WARNING: Your kernel does not support memory swappiness capabilities, memory swappiness discarded.</span><br><span class="line">root@<span class="number">7672</span>f24<span class="built_in">fc</span>1a4:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">PRETTY_NAME=<span class="string">"Raspbian GNU/Linux 8 (jessie)"</span></span><br><span class="line">NAME=<span class="string">"Raspbian GNU/Linux"</span></span><br><span class="line">VERSION_ID=<span class="string">"8"</span></span><br><span class="line">VERSION=<span class="string">"8 (jessie)"</span></span><br><span class="line">ID=raspbian</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">HOME_URL=<span class="string">"http://www.raspbian.org/"</span></span><br><span class="line">SUPPORT_URL=<span class="string">"http://www.raspbian.org/RaspbianForums"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"http://www.raspbian.org/RaspbianBugs"</span></span><br><span class="line"></span><br><span class="line">root@<span class="number">7672</span>f24<span class="built_in">fc</span>1a4:/<span class="comment"># exit</span></span><br></pre></td></tr></table></figure>
<p>OK, you’re done.</p>
<p>原文链接:<br><a href="https://github.com/umiddelb/armhf/wiki/Get-Docker-up-and-running-on-the-RaspberryPi-(ARMv6)-in-four-steps-(Wheezy" target="_blank" rel="external">https://github.com/umiddelb/armhf/wiki/Get-Docker-up-and-running-on-the-RaspberryPi-(ARMv6)-in-four-steps-(Wheezy</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>This tutorial describes useful things if you want to set up and run Docker on your RaspberryPi from scratch. If you prefer a ready to use]]>
    </summary>
    
      <category term="docker" scheme="http://gwpost.github.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chapter4-Working with Docker images and repositories]]></title>
    <link href="http://gwpost.github.com/2016/04/22/docker/docker-chapter4/"/>
    <id>http://gwpost.github.com/2016/04/22/docker/docker-chapter4/</id>
    <published>2016-04-22T12:04:56.000Z</published>
    <updated>2016-04-22T07:42:30.692Z</updated>
    <content type="html"><![CDATA[<p>We’ll learn a lot more about Docker images, <strong>what they are, how to manage them, how to modify them, and how to create, store, and share your own images</strong>.We’ll also examine the <strong>repositories</strong> that hold images and the <strong>registries</strong> that store repositories.</p>
<h2 id="Images">Images</h2><ol>
<li>Docker images is the building blocks from which we launch containers.</li>
<li>A Docker image is made up of filesystems layered over each other. At the base is a <strong>boot filesystem</strong>, <strong>bootfs</strong>, which resembles the typical Linux/Unix boot filesystem. A Docker user will probably never interact with the boot filesystem. Indeed, when a container has booted, it is moved into memory, and the boot filesystem is unmounted to free up the RAM used by the initrd disk image.</li>
<li>Docker next layers a <strong>root filesystem</strong>, <strong>rootfs</strong>, on top of the boot filesystem. This rootfs can be one or more <strong>operating systems</strong> (e.g., a Debian or Ubuntu filesystem).<br>In the Docker world, however, the root filesystem stays in <strong>read-only</strong> mode, and Docker takes advantage of a <strong>union mount</strong> to add more read-only filesystems onto the root filesystem.<br>The <strong>union mount</strong> overlays the filesystems on top of one another so that the resulting filesystem may contain files and subdirectories from any or all of the underlying filesystems.</li>
<li>Docker calls each of these filesystems <strong>images</strong>.</li>
<li>The image below is called the <strong>parent image</strong> and you can traverse each layer until you reach the bottom of the image stack where the final image is called the <strong>base image</strong>.</li>
<li>When a container is launched from an image, Docker mounts a <strong>read-write</strong> filesystem on top of any layers below.This is where whatever processes we want our Docker container to run will execute.</li>
<li>When Docker first starts a container, the initial read-write layer is empty. As changes occur, they are applied to this layer;</li>
<li>This pattern is traditionally called <strong>“copy on write”</strong> and is one of the features that makes Docker so powerful. Each read-only image layer is <strong>read-only</strong>; this image never changes. When a container is created, Docker builds from the stack of images and then adds the <strong>read-write</strong> layer on top. That layer, combined with the knowledge of the image layers below it and some configuration data, form the container.</li>
</ol>
<p><img src="./filesystem.png" alt=""></p>
<h2 id="Listing_Docker_images">Listing Docker images</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> docker images</span><br></pre></td></tr></table></figure>
<ol>
<li>Local images live on our local Docker host in the <strong>/var/lib/docker directory</strong>. Each image will be inside a directory named for your <strong>storage driver</strong>;for example, <strong>aufs</strong> or <strong>devicemapper</strong>.</li>
<li>Images are stored in repositories. You can think of an image repository as being much like a <strong>Git repository</strong>. It contains images, layers, and metadata about those images.</li>
<li>We identify each image inside that repository by what Docker calls <strong>tags</strong>.</li>
<li>We can refer to a specific image inside a repository by suffixing the repository name with <strong>a colon and a tag name</strong>.</li>
</ol>
<h2 id="Repositories">Repositories</h2><p>There are two types of repositories: <strong>user repositories</strong>, which contain images contributed by Docker users, and <strong>top-level repositories</strong>, which are controlled by the people behind Docker.A user repository takes the form of a <strong>username and a repository name</strong>.A top-level repository only has a <strong>repository name</strong> like ubuntu.</p>
<h2 id="Pulling_images">Pulling images</h2><p> When we run a container from images with the <strong>docker run</strong> command,by default,if you don’t specify a specific tag, Docker will download the <strong>latest tag</strong>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pulling the fedora image</span></span><br><span class="line">sudo docker pull fedora</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Viewing the fedora image</span></span><br><span class="line">sudo docker images fedora</span><br></pre></td></tr></table></figure>
<h2 id="Searching_for_images">Searching for images</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker search puppet</span><br></pre></td></tr></table></figure>
<p><img src="./search.png" alt=""></p>
<h2 id="Two_ways_to_create_a_Docker_image">Two ways to create a Docker image</h2><ol>
<li>Via the <strong>docker commit</strong> command(Not recommended);</li>
<li>Via the <strong>docker build</strong> command with a Dockerfile;  </li>
</ol>
<h2 id="Using_Docker_commit_to_create_images">Using Docker commit to create images</h2><h3 id="Logging_into_the_Docker_Hub">Logging into the Docker Hub</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login</span><br></pre></td></tr></table></figure>
<h3 id="Committing_the_custom_container">Committing the custom container</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To find the ID of the last created container</span></span><br><span class="line">docker ps <span class="operator">-l</span> -q</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Commit the comtainer</span></span><br><span class="line">sudo docker commit <span class="number">4</span>aab3ce3cb76 jamtur01/apache2</span><br></pre></td></tr></table></figure>
<p>The docker commit command only commits the differences between the image the container was created from and the current state of the container.</p>
<h2 id="Building_images_with_a_Dockerfile">Building images with a Dockerfile</h2><h3 id="Docker_executing_instructions_roughly_follow_a_workflow">Docker executing instructions roughly follow a workflow</h3><ul>
<li>Docker runs a container from the image；</li>
<li>An instruction executes and makes a change to the container；</li>
<li>Docker runs the equivalent of docker commit to commit a new layer；</li>
<li>Docker then runs a new container from this new image；</li>
<li>The next instruction in the file is executed, and the process repeats until all instructions have been executed；</li>
</ul>
<h3 id="The_RUN_instruction_in_exec_form">The RUN instruction in exec form</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [ <span class="string">"apt-get"</span>, <span class="string">" install"</span>, <span class="string">"-y"</span>, <span class="string">"nginx"</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="Running_the_Dockerfile">Running the Dockerfile</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker build -t=<span class="string">"jamtur01/static_web"</span> .</span><br></pre></td></tr></table></figure>
<p><strong>-t</strong> option to mark our resulting image with a repository and a name</p>
<h3 id="Dockerfiles_and_the_build_cache">Dockerfiles and the build cache</h3><p>If we did not need to change anything in Steps 1 to 3, then Docker would use the previously built images as a cache and a starting point. Essentially, it’d start the build process straight from Step 4.</p>
<h3 id="Using_the_docker_history_command">Using the docker history command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># see each of the image layers inside  image and the Dockerfile instruction that created them.</span></span><br><span class="line">sudo docker <span class="built_in">history</span> <span class="number">22</span>d47c8cb6e5</span><br></pre></td></tr></table></figure>
<h3 id="Viewing_the_Docker_port_mapping">Viewing the Docker port mapping</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Exposing a port with docker run</span></span><br><span class="line">sudo docker run <span class="operator">-d</span> -P --name static_web jamtur01/static_web</span><br></pre></td></tr></table></figure>
<p>Docker also has a shortcut, -P, that allows us to expose all ports we’ve specified via EXPOSE instructions in our Dockerfile.It would also expose any additional ports we had specified with other EXPOSE instructions in the Dockerfile that built our image.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Viewing the Docker port mapping</span></span><br><span class="line">sudo docker ps <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The docker port command</span></span><br><span class="line">sudo docker port <span class="number">6751</span>b94bb5c0 <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>We’ve specified the container ID and the container port for which we’d like to see the mapping.</p>
<h2 id="Dockerfile_instructions">Dockerfile instructions</h2><h3 id="FROM">FROM</h3><h3 id="MAINTAINER">MAINTAINER</h3><h3 id="ENV">ENV</h3><h3 id="RUN">RUN</h3><p>The RUN instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the Dockerfile.</p>
<p>RUN是在<strong>building image</strong>时会运行的指令, 在Dockerfile中可以写多条RUN指令.<br>CMD和ENTRYPOINT则是在运行container 时会运行的指令, 都只能写<strong>一条</strong>, 如果写了多条, 则<strong>最后一条生效</strong>.<br>CMD和ENTRYPOINT的区别是:CMD在运行时会被command<strong>覆盖</strong>, ENTRYPOINT不会被运行时的command覆盖, 但是也可以指定.</p>
<h3 id="CMD">CMD</h3><p>The CMD instruction specifies the command to run when a container is <strong>launched</strong>. It is similar to the RUN instruction, but rather than running the command when the container is being built, it will specify the command to run when the container is launched, much like specifying a command to run when launching a container with the docker run command.</p>
<p>You can also specify the CMD instruction without an array, in which case Docker will prepend /bin/sh -c to the command. This may result in unexpected behavior when the command is executed. As a result, it is recommended that you always use the array syntax.</p>
<p>Instead of launching a shell, the container merely returned the list of running processes and stopped, overriding the command specified in the CMD instruction.</p>
<h3 id="ENTRYPOINT">ENTRYPOINT</h3><p>The ENTRYPOINT instruction provides a command that isn’t as easily overridden. Instead, any arguments we specify on the docker run command line will be passed as arguments to the command specified in the ENTRYPOINT.</p>
<h3 id="WORKDIR">WORKDIR</h3><p>The WORKDIR instruction provides a way to set the working directory for the con- tainer and the ENTRYPOINT and/or CMD to be executed when a container is launched from the image.</p>
<p>You can override the working directory at runtime with the -w flag,</p>
<h3 id="ENV-1">ENV</h3><p>The ENV instruction is used to set environment variables during the image build process.<br>You can also pass environment variables on the docker run command line using the -e flag.</p>
<h3 id="USER">USER</h3><p>The USER instruction specifies a user that the image should be run as.<br>You can also override this at runtime by specifying the -<strong>u</strong> flag with the <strong>docker run</strong> command.<br>The default user if you don’t specify the USER instruction is <strong>root</strong>.</p>
<h3 id="VOLUME">VOLUME</h3><p>The VOLUME instruction adds volumes to any container created from the image. A volume is a specially designated directory within one or more containers that bypasses the Union File System to provide several useful features for persistent or shared data:</p>
<ul>
<li>Volumes can be shared and reused between containers.</li>
<li>A container doesn’t have to be running to share its volumes.</li>
<li>Changes to a volume are made directly.</li>
<li>Changes to a volume will not be included when you update an image.</li>
<li>Volumes persist until no containers use them.</li>
</ul>
<p>This allows us to add data (like source code), a database, or other content into an image without committing it to the image and allows us to share that data between containers. This can be used to do testing with containers and an application’s code, manage logs, or handle databases inside a container.</p>
<h3 id="ADD">ADD</h3><p>The ADD instruction adds files and directories from our build environment into our image.<br>When ADD’ing files Docker uses the ending character of the destination to deter- mine what the source is. If the destination ends in a /, then it considers the source a directory. If it doesn’t end in a /, it considers the source a file.<br>If a tar archive (valid archive types include gzip, bzip2, xz) is specified as the source file, then Docker will automatically unpack it for you.<br>New files and directories will be created with a mode of 0755 and a UID and GID of 0.</p>
<h3 id="COPY">COPY</h3><p>The COPY instruction is purely focused on copying local files from the build context and does not have any extraction or decompression capabilities.</p>
<p>The source of the files must be the path to a file or directory relative to the build context, the local source directory in which your Dockerfile resides. You cannot copy anything that is outside of this directory, because the build context is up- loaded to the Docker daemon, and the copy takes place there.</p>
<p>Any files and directories created by the copy will have a UID and GID of 0.</p>
<h3 id="ONBUILD">ONBUILD</h3><p>The ONBUILD instruction adds triggers to images. A trigger is executed when the image is used as the basis of another image.<br>The ONBUILD triggers are executed in the order specified in the parent image and are only inherited once.</p>
<h2 id="Pushing_images_to_the_Docker_Hub">Pushing images to the Docker Hub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push static_web</span><br></pre></td></tr></table></figure>
<h2 id="Deleting_an_image">Deleting an image</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi jamtur01/static_web</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deleting all images</span></span><br><span class="line">sudo docker rmi `docker images <span class="operator">-a</span> -q`</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>We’ll learn a lot more about Docker images, <strong>what they are, how to manage them, how to modify them, and how to create, store, and ]]>
    </summary>
    
      <category term="docker" scheme="http://gwpost.github.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chapter3-Getting Started with Docker]]></title>
    <link href="http://gwpost.github.com/2016/04/21/docker/docker-chapter3/"/>
    <id>http://gwpost.github.com/2016/04/21/docker/docker-chapter3/</id>
    <published>2016-04-21T12:03:56.000Z</published>
    <updated>2016-04-22T03:06:06.053Z</updated>
    <content type="html"><![CDATA[<p>We’re going to start with <strong>checking that Docker is working correctly</strong>, and then we’re going to take a look at the basic Docker workflow: <strong>creating and managing containers</strong>. We’ll take a container through its typical lifecycle from <strong>creation to a managed state and then stop and remove it</strong>.</p>
<h2 id="Ensuring_Docker_is_ready">Ensuring Docker is ready</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br></pre></td></tr></table></figure>
<p>This will show a list of any <strong>containers</strong>, any <strong>images</strong> (the building blocks Docker uses to build containers), the execution and <strong>storage drivers Docker</strong> is using, and its <strong>basic configuration</strong>.<br><img src="./docker-info.png" alt=""></p>
<p>The single binary, docker, can act as both <strong>client and server</strong>. As a client, the docker binary passes requests to the Docker daemon (e.g., asking it to return information about itself), and then processes those requests when they are returned.</p>
<h2 id="Building_our_first_container">Building our first container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>The <strong>-i</strong> flag keeps STDIN open from the container, even if we’re not attached to it. This persistent standard input is one half of what we need for an interactive shell.<br>The <strong>-t</strong> flag is the other half and tells Docker to assign a pseudo-tty to the container we’re about to create. This provides us with an interactive shell in the new container.<br><img src="./run.png" alt=""></p>
<h2 id="Working_with_our_first_container">Working with our first container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Checking the container's hostname</span></span><br><span class="line">hostname</span><br><span class="line"><span class="comment"># Checking the container's /etc/hosts</span></span><br><span class="line">cat /etc/hosts</span><br><span class="line"><span class="comment"># Checking the container's interfaces</span></span><br><span class="line">ip a</span><br><span class="line"><span class="comment"># Checking container's processes</span></span><br><span class="line">ps -aux</span><br><span class="line"><span class="comment"># Installing a package in our first container</span></span><br><span class="line">apt-get update &amp;&amp; apt-get install vim</span><br><span class="line"><span class="comment"># When you're done, type exit, and you'll return to the command prompt of your Ubuntu host</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h1 id="Listing_containers">Listing containers</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps <span class="operator">-a</span></span><br></pre></td></tr></table></figure>
<p><img src="./ps.png" alt=""><br>Once we exited the container, that command ended, and the container was stopped.The container still exists.</p>
<h2 id="Container_naming">Container naming</h2><p>If we want to specify a particular container name in place of the automatically generated name, we can do so using the <code>--name</code> flag.<br>Names are unique. If we try to create two containers with the same name, the command will fail. We need to delete the previous container with the same name before we can create a new one. We can do so with the docker rm command.</p>
<h2 id="Starting_a_stopped_container">Starting a stopped container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start bob_the_container</span><br></pre></td></tr></table></figure>
<h2 id="Attaching_to_a_container">Attaching to a container</h2><p>There is an interactive session waiting on our running container. We can reattach to that session using the docker attach command.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker attach bob_the_container</span><br></pre></td></tr></table></figure></p>
<p>You might need to hit <strong>Enter</strong> to bring up the prompt.</p>
<h2 id="Creating_daemonized_containers">Creating daemonized containers</h2><p>Daemonized containers don’t have the interactive session we’ve just used and are ideal for running applications and services.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name daemon_dave <span class="operator">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Seeing_what’s_happening_inside_our_container">Seeing what’s happening inside our container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs daemon_dave</span><br><span class="line">sudo docker logs <span class="operator">-f</span> daemon_dave</span><br></pre></td></tr></table></figure>
<h2 id="Inspecting_the_container’s_processes">Inspecting the container’s processes</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker top daemon_dave</span><br></pre></td></tr></table></figure>
<h2 id="Stopping_a_daemonized_container">Stopping a daemonized container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop daemon_dave</span><br></pre></td></tr></table></figure>
<h2 id="Showing_the_last_X_containers,_running_or_stopped">Showing the last <code>X</code> containers, running or stopped</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -n x</span><br></pre></td></tr></table></figure>
<h2 id="Finding_out_more_about_our_container">Finding out more about our container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect daemon_dave</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Selectively inspecting a container</span></span><br><span class="line">sudo docker inspect --format=<span class="string">'&#123;&#123; .State.Running &#125;&#125;'</span> daemon_dave</span><br></pre></td></tr></table></figure>
<p>Docker works by exploring the <strong>/var/lib/docker</strong> directory. This directory holds your <strong>images, containers, and container configuration</strong>. You’ll find all your containers in the <strong>/var/lib/docker/containers</strong> directory.</p>
<h2 id="Deleting_a_container">Deleting a container</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deleting multi containers</span></span><br><span class="line">sudo docker rm <span class="number">80430</span>f8d0921 <span class="number">80430</span>f8d0921</span><br><span class="line"><span class="comment"># Deleting all containers</span></span><br><span class="line">docker rm `docker ps <span class="operator">-a</span> -q`</span><br></pre></td></tr></table></figure>
<h2 id="Geting_help">Geting help</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">help</span> run</span><br><span class="line">man docker-run</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>We’re going to start with <strong>checking that Docker is working correctly</strong>, and then we’re going to take a look at the basic Do]]>
    </summary>
    
      <category term="docker" scheme="http://gwpost.github.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chapter2-Installing Docker]]></title>
    <link href="http://gwpost.github.com/2016/04/20/docker/docker-chapter2/"/>
    <id>http://gwpost.github.com/2016/04/20/docker/docker-chapter2/</id>
    <published>2016-04-20T07:45:35.000Z</published>
    <updated>2016-04-23T13:32:18.385Z</updated>
    <content type="html"><![CDATA[<h2 id="Prerequisites">Prerequisites</h2><p>Docker requires a 64-bit installation regardless of your Ubuntu version. Additionally, your kernel must be 3.10 at minimum. The latest 3.10 minor version or a newer maintained version are also acceptable.</p>
<p>To check your current kernel version, open a terminal and use <code>uname -r</code> to display your kernel version:</p>
<h2 id="Installing_docker">Installing docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker</span><br></pre></td></tr></table></figure>
<h3 id="Adding_current_user_to_docker_group">Adding current user to docker group</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd <span class="operator">-a</span> &lt;your_login&gt; docker</span><br></pre></td></tr></table></figure>
<p>Now, you can execute docker without root authority.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Prerequisites">Prerequisites</h2><p>Docker requires a 64-bit installation regardless of your Ubuntu version. Additionally, your kern]]>
    </summary>
    
      <category term="dokcer" scheme="http://gwpost.github.com/categories/dokcer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[配置树莓派无线网络]]></title>
    <link href="http://gwpost.github.com/2016/04/16/raspberrypi/network/"/>
    <id>http://gwpost.github.com/2016/04/16/raspberrypi/network/</id>
    <published>2016-04-16T01:33:36.000Z</published>
    <updated>2016-04-16T04:59:44.969Z</updated>
    <content type="html"><![CDATA[<h2 id="1-编辑网络接口配置文件">1.编辑网络接口配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br></pre></td></tr></table></figure>
<h2 id="2-修改无线网络信息和设置固定IP">2.修改无线网络信息和设置固定IP</h2><p><img src="./interfaces.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-编辑网络接口配置文件">1.编辑网络接口配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pr]]>
    </summary>
    
      <category term="raspberrrypi" scheme="http://gwpost.github.com/categories/raspberrrypi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu烧录树莓派镜像]]></title>
    <link href="http://gwpost.github.com/2016/04/16/raspberrypi/burn-img/"/>
    <id>http://gwpost.github.com/2016/04/16/raspberrypi/burn-img/</id>
    <published>2016-04-16T01:33:36.000Z</published>
    <updated>2016-04-16T03:04:01.598Z</updated>
    <content type="html"><![CDATA[<h2 id="1-查看TF的设备名">1.查看TF的设备名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p><img src="./fdisk.png" alt="fdisk"></p>
<h2 id="2-将镜像烧录至SD卡">2.将镜像烧录至SD卡</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd bs=<span class="number">4</span>M <span class="keyword">if</span>=<span class="number">2015</span>-<span class="number">05</span>-<span class="number">05</span>-wheezy-raspbian.img of=/dev/sdb</span><br></pre></td></tr></table></figure>
<p><img src="./dd.png" alt="fdisk"></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>bs</td>
<td>blocksize的缩写，表示一次写入多大的块</td>
<td>4M一般都没问题，如果不行，试试改成1M</td>
</tr>
<tr>
<td>if</td>
<td>input file缩写，表示镜像的路径</td>
<td>$12</td>
</tr>
<tr>
<td>of</td>
<td>output file的缩写 ，表示设备名</td>
<td>Linux上一切都是文件</td>
</tr>
</tbody>
</table>
<p>备注：因为dd命令没有进度显示，所以看上去可能感觉假死了，此时只要等待几分钟即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-查看TF的设备名">1.查看TF的设备名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></]]>
    </summary>
    
      <category term="raspberrrypi" scheme="http://gwpost.github.com/categories/raspberrrypi/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于记笔记的一些思考]]></title>
    <link href="http://gwpost.github.com/2016/04/15/writing-notes/"/>
    <id>http://gwpost.github.com/2016/04/15/writing-notes/</id>
    <published>2016-04-15T11:53:39.000Z</published>
    <updated>2016-04-15T11:58:32.582Z</updated>
    <content type="html"><![CDATA[<ol>
<li>因为你曾经在 Google 搜索结果里翻了好几页才找到的答案，下次搜索时还要再找一遍，效率是不高的</li>
<li>用纸记录笔记已经不适合。每次搬家或清理时，曾经写满笔记的小本子都会被我遗弃掉，如果不翻开那些小本子，我几乎不会记得我曾经记录过什么东西。一旦那些纸质笔记本被我扔掉，之前记录的所有笔记内容都会从我的记忆中抹去。</li>
<li>现在市面上大多数的笔记软件的文件存储都是使用私有格式，一旦它停止服务，你只能寄希望于它提供的导出功能，然后盼望着另外一家笔记软件能导入这些笔记</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>因为你曾经在 Google 搜索结果里翻了好几页才找到的答案，下次搜索时还要再找一遍，效率是不高的</li>
<li>用纸记录笔记已经不适合。每次搬家或清理时，曾经写满笔记的小本子都会被我遗弃掉，如果不翻开那些小本子，我几乎不会记得我曾经记录过什么东西。一旦那些]]>
    </summary>
    
      <category term="MyThinking" scheme="http://gwpost.github.com/categories/MyThinking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[thesis]]></title>
    <link href="http://gwpost.github.com/2016/01/14/thesis-2016-01-14/"/>
    <id>http://gwpost.github.com/2016/01/14/thesis-2016-01-14/</id>
    <published>2016-01-14T02:43:09.000Z</published>
    <updated>2016-01-14T02:45:44.368Z</updated>
    <content type="html"><![CDATA[<p>国家期刊出版格式要求在中图分类号的下面应标出文献标识码，规定如下：<br>作者可从下列A、B、C、D、E中选用一种标识码来揭示文章的性质：<br>A—理论与应用研究学术论文（包括综述报告）；<br>B—实用性成果报告（科学技术）、理论学习与社会实践总结（科技）；<br>C—业务指导与技术管理的文章（包括特约评论）；<br>D—一般性通讯、报导、专访等；<br>E—文件、资料、人物、书刊、知识介绍等。</p>
<p>注：英文的文献标识码应与中文对应。<br>[参考文献类型标识码]<br>M——专著 Monograph ；<br>C——-论文集Collection ；<br>N——报纸文章 News；<br> J——期刊文章 Journal；<br>D——学位论文 Degree；<br>R——报告 Report；<br> S——标准 Standard；<br> P——专利 Patent；<br>A——专著、论文集中的析出文献 Article；<br>Z——其它末说明文献 </p>
<p>（1）文献类型标识：专著[M]；期刊[J]；论文集[c]；学位论文[D]；<br>标准[S]；报告[R]；专利[P]；报纸[N]；<br>（2）电子文献类型标识：数据库[DB]；计算机程序[CP]；电子公告[EB]；<br>（3）电子文献的载体类型及其标识：联机网上数据库[DB／OL]；</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>国家期刊出版格式要求在中图分类号的下面应标出文献标识码，规定如下：<br>作者可从下列A、B、C、D、E中选用一种标识码来揭示文章的性质：<br>A—理论与应用研究学术论文（包括综述报告）；<br>B—实用性成果报告（科学技术）、理论学习与社会实践总结（科技）；<br>C—]]>
    </summary>
    
      <category term="thesis" scheme="http://gwpost.github.com/categories/thesis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive学习笔记]]></title>
    <link href="http://gwpost.github.com/2016/01/09/bigdata/hive-learn-note-2016-01-09/"/>
    <id>http://gwpost.github.com/2016/01/09/bigdata/hive-learn-note-2016-01-09/</id>
    <published>2016-01-09T06:57:36.000Z</published>
    <updated>2016-01-09T07:56:18.728Z</updated>
    <content type="html"><![CDATA[<p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<h1 id="定义">定义</h1><p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。<br>Hive 没有专门的数据格式。 Hive 可以很好的工作在 Thrift 之上，控制分隔符，也允许用户指定数据格式。</p>
<h1 id="适用场景">适用场景</h1><p>Hive 构建在基于静态批处理的Hadoop 之上，Hadoop 通常都有较高的延迟并且在作业提交和调度的时候需要大量的开销。因此，Hive 并不能够在大规模数据集上实现低延迟快速的查询，例如，Hive 在几百MB 的数据集上执行查询一般有分钟级的时间延迟。因此，Hive 并不适合那些需要低延迟的应用，例如，联机事务处理（OLTP）。Hive 查询操作过程严格遵守Hadoop MapReduce 的作业执行模型，Hive 将用户的HiveQL 语句通过解释器转换为MapReduce 作业提交到Hadoop 集群上，Hadoop 监控作业执行过程，然后返回作业执行结果给用户。Hive 并非为联机事务处理而设计，Hive 并不提供实时的查询和基于行级的数据更新操作。Hive 的最佳使用场合是大数据集的批处理作业，例如，网络日志分析。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapRe]]>
    </summary>
    
      <category term="bigdata" scheme="http://gwpost.github.com/categories/bigdata/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fabric]]></title>
    <link href="http://gwpost.github.com/2015/12/30/fabric-2015-12-30/"/>
    <id>http://gwpost.github.com/2015/12/30/fabric-2015-12-30/</id>
    <published>2015-12-30T08:13:50.000Z</published>
    <updated>2015-12-30T08:27:45.935Z</updated>
    <content type="html"><![CDATA[<h1 id="What_is_Fabric_?">What is Fabric ?</h1><p> <code>Fabric</code> is a Python (2.5-2.7) library and command-line tool for streamlining <code>the use of SSH</code> for <code>application deployment</code> or <code>systems administration tasks</code>.</p>
<p>More specifically, Fabric is:   </p>
<ul>
<li>A tool that lets you<code>execute arbitrary Python functions</code> via the command line;  </li>
<li>A library of subroutines (built on top of a lower-level library) to make <code>executing shell commands over SSH</code> easy and Pythonic.</li>
</ul>
<p>Naturally, most users combine these two things, using Fabric to write and execute Python functions, or tasks, to automate interactions with remote servers. Let’s take a look.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="What_is_Fabric_?">What is Fabric ?</h1><p> <code>Fabric</code> is a Python (2.5-2.7) library and command-line tool for streamlining ]]>
    </summary>
    
      <category term="python" scheme="http://gwpost.github.com/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技术文章,每天读一点]]></title>
    <link href="http://gwpost.github.com/2015/12/18/helpful-links-2015-12-18/"/>
    <id>http://gwpost.github.com/2015/12/18/helpful-links-2015-12-18/</id>
    <published>2015-12-18T12:57:35.000Z</published>
    <updated>2015-12-18T14:37:27.906Z</updated>
    <content type="html"><![CDATA[<h1 id="Java">Java</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BKpdfHL&amp;up=" target="_blank" rel="external">Java应用一般架构</a></li>
</ul>
<h1 id="Linux">Linux</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BSA3uw4&amp;up=" target="_blank" rel="external">为什么说systemd是系统管理员的利器</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BS4R6tN&amp;up=" target="_blank" rel="external">Linux运维比较实用的工具</a></li>
</ul>
<h1 id="Python">Python</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Bc1kOa6&amp;up=1" target="_blank" rel="external">亲测，手把手教你用Python抢票</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Bcaz4Wg&amp;up=313" target="_blank" rel="external">12306的变态验证码算什么？我有Python神器</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BVUao6L&amp;up=" target="_blank" rel="external">7 款 Python 可视化工具对比</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BVMUhV8&amp;up=" target="_blank" rel="external">Python 程序员都会喜欢的 6 个库</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BTOYAi7&amp;up=" target="_blank" rel="external">告诉你，为什么开发、运维和数据都需要用Python！</a></li>
</ul>
<h1 id="大数据">大数据</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BeQTyER&amp;up=166" target="_blank" rel="external">大数据分析方法解读以及相关工具介绍</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BfKT3RW&amp;up=188" target="_blank" rel="external">2分钟读懂大数据框架Hadoop和Spark的异同</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BbrgbhX&amp;up=200" target="_blank" rel="external">百度资深专家：我在大数据项目中踩过的那些坑</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BYB5bcu&amp;up=392" target="_blank" rel="external">带您了解大数据</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BK03pY8&amp;up=313" target="_blank" rel="external">数据科学 怎样进行大数据的入门级学习？</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0AgT4SZD&amp;up=" target="_blank" rel="external">三种数据部门架构优与劣</a></li>
</ul>
<h1 id="数据可视化">数据可视化</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BZIv9nk&amp;up=245" target="_blank" rel="external">数据可视化、信息可视化、知识可视化</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Bg2v0sH&amp;up=200" target="_blank" rel="external">14款基于javascript的数据可视化工具</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BRr2NDS&amp;up=" target="_blank" rel="external">大数据有哪些炫酷可视化应用？</a></li>
</ul>
<h1 id="机器学习">机器学习</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Bi3GW7G&amp;up=1113" target="_blank" rel="external">数据科学中最好的5个机器学习API</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BbDX2hW&amp;up=392" target="_blank" rel="external">机器学习初识</a></li>
</ul>
<h1 id="数据挖掘">数据挖掘</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0AuVqVkf&amp;up=undefined" target="_blank" rel="external">互联网和金融，在数据挖掘上究竟存在什么区别</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0AtTLPCv&amp;up=" target="_blank" rel="external">数据科学家知识体系与数据分析完整流程</a></li>
</ul>
<h1 id="爬虫">爬虫</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BgKrb6I&amp;up=561" target="_blank" rel="external">雅虎开源解析 HTML 页面数据的 Web 爬取工具 Anthelion</a></li>
</ul>
<h1 id="Docker">Docker</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BfnnTpw&amp;up=437" target="_blank" rel="external">Docker脑洞大开的奇思妙用</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BTfnoQz&amp;up=" target="_blank" rel="external">用浏览器管理 Docker</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BSEroZN&amp;up=" target="_blank" rel="external">Docker容器 vs 全虚拟化</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BQMpc3B&amp;up=" target="_blank" rel="external">如何使用docker精简开发过程?</a></li>
</ul>
<h1 id="运维">运维</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BhK9lb8&amp;up=471" target="_blank" rel="external">运维排查问题的方法和脚本</a></li>
</ul>
<h1 id="AngularJs">AngularJs</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BSbQPQS&amp;up=" target="_blank" rel="external">10 个非常有用的 AngularJS 框架</a></li>
</ul>
<h1 id="前端">前端</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BZYZaLs&amp;up=313" target="_blank" rel="external">29个前端工程师和设计师必备的Chrome插件</a></li>
</ul>
<h1 id="树莓派">树莓派</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BU6smrN&amp;up=" target="_blank" rel="external">树莓派初学者？先做做这十个项目吧</a></li>
</ul>
<h1 id="Arduino">Arduino</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BhbEX37&amp;up=188" target="_blank" rel="external">控制Arduino的利器-Windows Remote Arduino</a></li>
</ul>
<h1 id="程序员提高">程序员提高</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BfkfiqM&amp;up=2381" target="_blank" rel="external">26岁程序员的出路</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BeBX8zt&amp;up=414" target="_blank" rel="external">如何利用碎片时间，和别人拉开距离</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BenLIIw&amp;up=4" target="_blank" rel="external">菜鸟程序员如何才能快速提高自己的技术</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BFMe5nz&amp;up=256" target="_blank" rel="external">可以使你成为更优秀程序员的5个好习惯</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Banmzzo&amp;up=787" target="_blank" rel="external">论程序员的自我修养</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0Bf5fGLG&amp;up=undefined" target="_blank" rel="external">GitHub上整理的一些工具</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BRzHg9t&amp;up=" target="_blank" rel="external">一个印度程序员的生活领悟</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BSV9mTN&amp;up=" target="_blank" rel="external">程序员如何在技术面试表现得更出色？</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BTWLi3a&amp;up=" target="_blank" rel="external">阿里员工的离职总结：如何在大公司生存？</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BRyBWvS&amp;up=" target="_blank" rel="external">技术人员必读的7佳高端访谈录</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BSquaSs&amp;up=" target="_blank" rel="external">方法论丨程序员的有效学习策略</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BfUNZ0H&amp;up=154" target="_blank" rel="external">麻省理工和加州理工的学霸是如何学习的?</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BUnJg5m&amp;up=" target="_blank" rel="external">写给程序猿的把妹指南:概述篇</a></li>
<li><a href="http://mt.sohu.com/20151128/n428663716.shtml" target="_blank" rel="external">李嘉诚的人生修行：孤独是一种力量</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BN6RALJ&amp;up=" target="_blank" rel="external">要创业，你必须知道这些团队协作工具</a></li>
</ul>
<h1 id="PPT">PPT</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BXtbxhg&amp;up=" target="_blank" rel="external">史上最全PPT模板网站就在这里</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BVooD0Y&amp;up=" target="_blank" rel="external">这里有最全的PPT模板资源，这里有全套的解决方案！</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BVA3Zb0&amp;up=" target="_blank" rel="external">你们做的PPT为什么这么垃圾?</a></li>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BRSp64r&amp;up=" target="_blank" rel="external">怎样做好学术 PPT？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Java">Java</h1><ul>
<li><a href="http://www.yidianzixun.com/home?page=article&amp;id=0BKpdfHL&amp;up=" target="_blank" rel="external]]>
    </summary>
    
      <category term="links" scheme="http://gwpost.github.com/categories/links/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WIFI密码破解]]></title>
    <link href="http://gwpost.github.com/2015/11/27/wifi-crack-2015-11-27/"/>
    <id>http://gwpost.github.com/2015/11/27/wifi-crack-2015-11-27/</id>
    <published>2015-11-27T11:59:36.000Z</published>
    <updated>2015-11-27T14:17:45.438Z</updated>
    <content type="html"><![CDATA[<h1 id="安装Wireshark">安装Wireshark</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install wireshark</span><br><span class="line">$ sudo dpkg-reconfigure wireshark-common </span><br><span class="line">$ sudo usermod <span class="operator">-a</span> -G wireshark <span class="variable">$USER</span></span><br><span class="line">$ sudo reboot </span><br><span class="line">或者`注销`</span><br><span class="line">$ gnome-session-quit --logout --no-prompt</span><br></pre></td></tr></table></figure>
<h1 id="WIFI密码破解">WIFI密码破解</h1><ol>
<li><p>安装工具包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo apt-get install aircrack-ng</span><br></pre></td></tr></table></figure>
</li>
<li><p>把电脑网卡变成监听模式  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看有哪些网卡</span></span><br><span class="line">$ iwconfig</span><br><span class="line"><span class="comment"># 启动网卡的监听模式 </span></span><br><span class="line">$ sudo airmon-ng start wlan0</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描周围无线WIFI</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo airodump-ng mon0</span><br></pre></td></tr></table></figure>
</li>
<li><p>专门监听老王的WIFI(老王和路由器的数据传输)</p>
</li>
<li>发起攻击,模拟WIFI路由器单播,向老王发出断开链接的请求<br>sudo aireplay-ng -0 1 -a C0:61:18:89:F8:8A -h 74:E5:0B:80:E4:60 mon0</li>
<li>老王的电脑断开链接,自动重新建立链接,捕获4次握手包</li>
<li>4次握手包里包含加密的密码,SHA1,MD5</li>
<li>暴力破解,穷举字典破解<br>aircrack-ng -w password linuxcpp-01.ivs</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装Wireshark">安装Wireshark</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span ]]>
    </summary>
    
      <category term="network" scheme="http://gwpost.github.com/categories/network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker学习]]></title>
    <link href="http://gwpost.github.com/2015/11/11/docker/docker-2015-11-11/"/>
    <id>http://gwpost.github.com/2015/11/11/docker/docker-2015-11-11/</id>
    <published>2015-11-11T11:45:33.000Z</published>
    <updated>2016-04-16T08:14:11.127Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker命令">Docker命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">sudo docker info</span><br><span class="line">sudo status docker</span><br><span class="line">sudo start docker</span><br><span class="line">sudo  stop docker</span><br><span class="line">sudo docker run -i -t ubuntu /bin/bash --name containername</span><br><span class="line">hostname</span><br><span class="line">cat /etc/hosts</span><br><span class="line">ip a</span><br><span class="line">ps -aux</span><br><span class="line">sudo docker ps <span class="operator">-a</span></span><br><span class="line">sudo docker ps</span><br><span class="line"> sudo docker ps <span class="operator">-l</span></span><br><span class="line"> sudo docker start  containername</span><br><span class="line"> sudo docker attach containername</span><br><span class="line">sudo docker run --name containername</span><br><span class="line">sudo docker run --name containername -w /var/<span class="built_in">log</span></span><br><span class="line">sudo docker run  -P container_port --name containername</span><br><span class="line">sudo docker run --name containername <span class="operator">-d</span>  -p host_port:container_port ubuntu /bin/sh -c <span class="string">"while true; do echo hello world;sleep 1;done"</span></span><br><span class="line">sudo docker logs containername</span><br><span class="line">sudo docker logs -ft containername</span><br><span class="line">sudo docker top containername</span><br><span class="line">sudo docker stop containername</span><br><span class="line">sudo docker ps -n <span class="number">3</span></span><br><span class="line">sudo docker inspect containername</span><br><span class="line">sudo docker inspect --format <span class="string">'&#123;&#123;.name&#125;&#125; &#123;&#123;.State.Running&#125;&#125;'</span>  containername</span><br><span class="line">/var/lib/docker</span><br><span class="line">sudo docker rm containername</span><br><span class="line">sudo docker rm `docker ps -aq`</span><br><span class="line">sudo docker images</span><br><span class="line">sudo docker pull  containername</span><br><span class="line">sudo docker pull  containername:<span class="number">20</span></span><br><span class="line">sudo docker images  containername</span><br><span class="line">sudo docker search containername</span><br><span class="line">sudo docker commit origincontainername newcontainername:tagname -m=<span class="string">"commit msg"</span> --author=<span class="string">"authorname"</span></span><br><span class="line">sudo docker build -t=<span class="string">"containername:tagname"</span> .</span><br><span class="line">sudo docker build --no-cache -t=<span class="string">"containername"</span></span><br><span class="line">ENV REFRESHED_AT <span class="number">2015</span>-<span class="number">11</span>-<span class="number">26</span></span><br><span class="line">sudo docker <span class="built_in">history</span> containername</span><br><span class="line">sudo docker port containername container_port</span><br><span class="line">sudo docker push username/containername</span><br><span class="line">sudo docker rmi  containername</span><br><span class="line">sudo docker rmi `docker ps -aq`</span><br><span class="line">ip a show docker0</span><br><span class="line">/var/lib/docker/volumes</span><br><span class="line">sudo docker inspect <span class="operator">-f</span> <span class="string">"&#123;&#123;.Volumes&#125;&#125;"</span>  containername</span><br><span class="line">sudo docker run <span class="operator">-d</span> -P --volumes-from  containernamefrom  containername</span><br><span class="line">sudo docker run <span class="operator">-d</span> --volumes-from containername</span><br><span class="line"></span><br><span class="line">sudo docker run -v /usr/<span class="built_in">local</span>/bin:/target jpetazzo/nsenter</span><br><span class="line">sudo nsenter --target <span class="number">17469</span> --mount --uts --ipc --net --pid</span><br><span class="line"></span><br><span class="line">sudo fig up <span class="operator">-d</span></span><br><span class="line">sudo fig ps</span><br><span class="line">sudo fig logs</span><br><span class="line">sudo fig stop</span><br><span class="line">sudo fig start</span><br><span class="line">sudo fig rm</span><br><span class="line"></span><br><span class="line">sudo docker -H  remoteIp:port info</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker命令">Docker命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class=]]>
    </summary>
    
      <category term="docker" scheme="http://gwpost.github.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux实用命令]]></title>
    <link href="http://gwpost.github.com/2015/11/10/linux/linux-2015-11-10/"/>
    <id>http://gwpost.github.com/2015/11/10/linux/linux-2015-11-10/</id>
    <published>2015-11-10T14:21:09.000Z</published>
    <updated>2016-01-15T06:59:47.875Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>查看Linux系统位数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uname <span class="operator">-a</span></span><br><span class="line">uname -m</span><br><span class="line">uname -m</span><br><span class="line">file  /sbin/init </span><br><span class="line">arch</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨机文件或目录的复制</p>
</li>
</ol>
<ul>
<li><p>从本地复制到远程-复制文件  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp <span class="built_in">local</span>_file remote_username@remote_ip:remote_folder   复制到remote_folder文件夹下</span><br><span class="line">scp <span class="built_in">local</span>_file remote_username@remote_ip:remote_folder/remote_file  文件重命名</span><br></pre></td></tr></table></figure>
</li>
<li><p>从本地复制到远程-复制目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r <span class="built_in">local</span>_folder remote_username@remote_ip:remote_folder   复制到remote_folder文件夹下</span><br></pre></td></tr></table></figure>
</li>
<li><p>从远程复制到本地-复制文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp remote_username@remote_ip:remote_folder/remote_file  <span class="built_in">local</span>_file   在本地当前路径创建<span class="built_in">local</span>_file</span><br><span class="line">scp remote_username@remote_ip:remote_folder/remote_file  <span class="built_in">local</span>_folder  复制到<span class="built_in">local</span>_folder文件夹下</span><br></pre></td></tr></table></figure>
</li>
<li><p>从远程复制到本地-复制目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp  -r  remote_username@remote_ip:remote_folder <span class="built_in">local</span>_folder   复制到<span class="built_in">local</span>_folder文件夹下</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Ubuntu安装Atom">Ubuntu安装Atom</h1><p>sudo add-apt-repository ppa:webupd8team/atom<br>sudo apt-get update<br>sudo apt-get install atom</p>
<h1 id="Ubuntu卸载Atom">Ubuntu卸载Atom</h1><p>sudo apt-get remove atom<br>sudo add-apt-repository –remove ppa:webupd8team/atom</p>
<p>以上只会卸载该软件，要卸载附加的一些软件包，请使用以下命令卸载多余的软件包：<br>sudo apt-get autoremove</p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>查看Linux系统位数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="li]]>
    </summary>
    
      <category term="linux" scheme="http://gwpost.github.com/categories/linux/"/>
    
  </entry>
  
</feed>
